# Frontend - Media Handling

This document outlines the media handling system for the CMS, explaining how images, videos, and other media files are managed and rendered on the frontend.

## Media System Overview

The media handling system consists of several components:

1. **Media Model**: Represents media files stored in the system
2. **Media Storage**: Handles file storage and retrieval
3. **Media Rendering**: Renders media in the frontend templates
4. **Image Processing**: Handles image resizing and optimization
5. **Media Gallery**: Provides a gallery interface for media collections

## Media Model

The `Media` model handles the storage and retrieval of media data:

```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

class Media extends Model
{
    protected $fillable = [
        'user_id',
        'name',
        'file_name',
        'mime_type',
        'path',
        'disk',
        'size',
        'alt_text',
        'caption',
        'width',
        'height',
        'metadata',
    ];

    protected $casts = [
        'metadata' => 'array',
        'width' => 'integer',
        'height' => 'integer',
        'size' => 'integer',
    ];

    // Relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the URL for this media file
     * 
     * @return string
     */
    public function getUrl()
    {
        return Storage::disk($this->disk)->url($this->path);
    }

    /**
     * Get the thumbnail URL for this media file
     * 
     * @param int $width
     * @param int $height
     * @return string
     */
    public function getThumbnailUrl($width = 200, $height = 200)
    {
        if (!$this->isImage()) {
            return $this->getPlaceholderUrl();
        }

        $thumbnailPath = $this->getThumbnailPath($width, $height);
        
        // Check if thumbnail exists
        if (!Storage::disk($this->disk)->exists($thumbnailPath)) {
            // Generate thumbnail
            app(MediaService::class)->generateThumbnail($this, $width, $height);
        }
        
        return Storage::disk($this->disk)->url($thumbnailPath);
    }

    /**
     * Get the path for a thumbnail
     * 
     * @param int $width
     * @param int $height
     * @return string
     */
    public function getThumbnailPath($width = 200, $height = 200)
    {
        $pathInfo = pathinfo($this->path);
        $extension = $pathInfo['extension'] ?? '';
        $filename = $pathInfo['filename'] ?? '';
        $directory = $pathInfo['dirname'] ?? '';
        
        return "{$directory}/thumbnails/{$filename}_{$width}x{$height}.{$extension}";
    }

    /**
     * Get a placeholder URL for non-image files
     * 
     * @return string
     */
    public function getPlaceholderUrl()
    {
        $type = explode('/', $this->mime_type)[0];
        
        switch ($type) {
            case 'video':
                return asset('themes/miata/images/placeholders/video.png');
            case 'audio':
                return asset('themes/miata/images/placeholders/audio.png');
            case 'application':
                if (Str::contains($this->mime_type, 'pdf')) {
                    return asset('themes/miata/images/placeholders/pdf.png');
                }
                return asset('themes/miata/images/placeholders/document.png');
            default:
                return asset('themes/miata/images/placeholders/file.png');
        }
    }

    /**
     * Check if this media is an image
     * 
     * @return bool
     */
    public function isImage()
    {
        return Str::startsWith($this->mime_type, 'image/');
    }

    /**
     * Check if this media is a video
     * 
     * @return bool
     */
    public function isVideo()
    {
        return Str::startsWith($this->mime_type, 'video/');
    }

    /**
     * Check if this media is an audio file
     * 
     * @return bool
     */
    public function isAudio()
    {
        return Str::startsWith($this->mime_type, 'audio/');
    }

    /**
     * Get the HTML for rendering this media
     * 
     * @param array $attributes Additional HTML attributes
     * @return string
     */
    public function render($attributes = [])
    {
        if ($this->isImage()) {
            return $this->renderImage($attributes);
        } elseif ($this->isVideo()) {
            return $this->renderVideo($attributes);
        } elseif ($this->isAudio()) {
            return $this->renderAudio($attributes);
        } else {
            return $this->renderFile($attributes);
        }
    }

    /**
     * Render an image
     * 
     * @param array $attributes
     * @return string
     */
    protected function renderImage($attributes = [])
    {
        $url = $this->getUrl();
        $alt = $this->alt_text ?? $this->name;
        
        $attributesStr = '';
        foreach ($attributes as $key => $value) {
            $attributesStr .= " {$key}=\"{$value}\"";
        }
        
        return "<img src=\"{$url}\" alt=\"{$alt}\"{$attributesStr}>";
    }

    /**
     * Render a video
     * 
     * @param array $attributes
     * @return string
     */
    protected function renderVideo($attributes = [])
    {
        $url = $this->getUrl();
        
        $attributesStr = '';
        foreach ($attributes as $key => $value) {
            $attributesStr .= " {$key}=\"{$value}\"";
        }
        
        return "<video controls{$attributesStr}><source src=\"{$url}\" type=\"{$this->mime_type}\">Your browser does not support the video tag.</video>";
    }

    /**
     * Render an audio file
     * 
     * @param array $attributes
     * @return string
     */
    protected function renderAudio($attributes = [])
    {
        $url = $this->getUrl();
        
        $attributesStr = '';
        foreach ($attributes as $key => $value) {
            $attributesStr .= " {$key}=\"{$value}\"";
        }
        
        return "<audio controls{$attributesStr}><source src=\"{$url}\" type=\"{$this->mime_type}\">Your browser does not support the audio tag.</audio>";
    }

    /**
     * Render a file
     * 
     * @param array $attributes
     * @return string
     */
    protected function renderFile($attributes = [])
    {
        $url = $this->getUrl();
        $name = $this->name;
        
        $attributesStr = '';
        foreach ($attributes as $key => $value) {
            $attributesStr .= " {$key}=\"{$value}\"";
        }
        
        return "<a href=\"{$url}\"{$attributesStr}>{$name}</a>";
    }
}
```

## Media Service

A dedicated service class handles media operations:

```php
namespace App\Services;

use App\Models\Media;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;
use Intervention\Image\Facades\Image;

class MediaService
{
    /**
     * Upload a media file
     *
     * @param UploadedFile $file
     * @param array $data
     * @param string $disk
     * @return Media
     */
    public function upload(UploadedFile $file, array $data = [], $disk = 'public')
    {
        // Generate a unique filename
        $filename = Str::uuid() . '.' . $file->getClientOriginalExtension();
        
        // Get the file path
        $path = 'uploads/' . date('Y/m/d') . '/' . $filename;
        
        // Store the file
        $file->storeAs(dirname($path), $filename, $disk);
        
        // Get file metadata
        $metadata = $this->getFileMetadata($file);
        
        // Create media record
        $media = Media::create([
            'user_id' => auth()->id(),
            'name' => $data['name'] ?? $file->getClientOriginalName(),
            'file_name' => $filename,
            'mime_type' => $file->getMimeType(),
            'path' => $path,
            'disk' => $disk,
            'size' => $file->getSize(),
            'alt_text' => $data['alt_text'] ?? null,
            'caption' => $data['caption'] ?? null,
            'width' => $metadata['width'] ?? null,
            'height' => $metadata['height'] ?? null,
            'metadata' => $metadata,
        ]);
        
        // Generate thumbnails for images
        if (Str::startsWith($file->getMimeType(), 'image/')) {
            $this->generateThumbnail($media);
        }
        
        return $media;
    }
    
    /**
     * Generate a thumbnail for an image
     *
     * @param Media $media
     * @param int $width
     * @param int $height
     * @return bool
     */
    public function generateThumbnail(Media $media, $width = 200, $height = 200)
    {
        if (!$media->isImage()) {
            return false;
        }
        
        $thumbnailPath = $media->getThumbnailPath($width, $height);
        $directory = dirname($thumbnailPath);
        
        // Create thumbnails directory if it doesn't exist
        if (!Storage::disk($media->disk)->exists("{$directory}")) {
            Storage::disk($media->disk)->makeDirectory("{$directory}");
        }
        
        // Get the image
        $image = Image::make(Storage::disk($media->disk)->path($media->path));
        
        // Resize the image
        $image->fit($width, $height, function ($constraint) {
            $constraint->aspectRatio();
            $constraint->upsize();
        });
        
        // Save the thumbnail
        $image->save(Storage::disk($media->disk)->path($thumbnailPath));
        
        return true;
    }
    
    /**
     * Get file metadata
     *
     * @param UploadedFile $file
     * @return array
     */
    protected function getFileMetadata(UploadedFile $file)
    {
        $metadata = [];
        
        // Get image metadata
        if (Str::startsWith($file->getMimeType(), 'image/')) {
            $image = Image::make($file->getRealPath());
            
            $metadata['width'] = $image->width();
            $metadata['height'] = $image->height();
            
            // Get EXIF data if available
            if (method_exists($image, 'exif')) {
                $exif = $image->exif();
                
                if ($exif) {
                    $metadata['exif'] = $exif;
                }
            }
        }
        
        return $metadata;
    }
    
    /**
     * Delete a media file
     *
     * @param Media $media
     * @return bool
     */
    public function delete(Media $media)
    {
        // Delete the file
        Storage::disk($media->disk)->delete($media->path);
        
        // Delete thumbnails
        $pathInfo = pathinfo($media->path);
        $filename = $pathInfo['filename'] ?? '';
        $directory = $pathInfo['dirname'] ?? '';
        
        $thumbnailPattern = "{$directory}/thumbnails/{$filename}_*";
        
        foreach (Storage::disk($media->disk)->files(dirname($thumbnailPattern)) as $file) {
            if (Str::startsWith(basename($file), $filename . '_')) {
                Storage::disk($media->disk)->delete($file);
            }
        }
        
        // Delete the media record
        return $media->delete();
    }
    
    /**
     * Get a responsive image HTML
     *
     * @param Media $media
     * @param array $sizes
     * @param array $attributes
     * @return string
     */
    public function getResponsiveImage(Media $media, array $sizes = [], array $attributes = [])
    {
        if (!$media->isImage()) {
            return $media->render($attributes);
        }
        
        // Default sizes
        $defaultSizes = [
            'xs' => 576,
            'sm' => 768,
            'md' => 992,
            'lg' => 1200,
            'xl' => 1400,
        ];
        
        $sizes = array_merge($defaultSizes, $sizes);
        
        // Generate srcset
        $srcset = [];
        
        foreach ($sizes as $size => $width) {
            // Generate thumbnail
            $this->generateThumbnail($media, $width, round($width * ($media->height / $media->width)));
            
            // Add to srcset
            $srcset[] = $media->getThumbnailUrl($width, round($width * ($media->height / $media->width))) . " {$width}w";
        }
        
        // Generate sizes attribute
        $sizesAttr = '(max-width: 576px) 100vw, (max-width: 1200px) 50vw, 33vw';
        
        if (isset($attributes['sizes'])) {
            $sizesAttr = $attributes['sizes'];
            unset($attributes['sizes']);
        }
        
        // Generate HTML
        $url = $media->getUrl();
        $alt = $media->alt_text ?? $media->name;
        
        $attributesStr = '';
        foreach ($attributes as $key => $value) {
            $attributesStr .= " {$key}=\"{$value}\"";
        }
        
        return "<img src=\"{$url}\" srcset=\"" . implode(', ', $srcset) . "\" sizes=\"{$sizesAttr}\" alt=\"{$alt}\"{$attributesStr}>";
    }
}
```

## Media Blade Component

A Blade component simplifies media rendering in templates:

```php
namespace App\View\Components;

use App\Models\Media;
use App\Services\MediaService;
use Illuminate\View\Component;

class MediaRenderer extends Component
{
    public $media;
    public $responsive;
    public $sizes;
    public $attributes;
    
    /**
     * Create a new component instance.
     *
     * @param Media $media
     * @param bool $responsive
     * @param array $sizes
     * @param array $attributes
     * @return void
     */
    public function __construct(Media $media, $responsive = false, $sizes = [], $attributes = [])
    {
        $this->media = $media;
        $this->responsive = $responsive;
        $this->sizes = $sizes;
        $this->attributes = $attributes;
    }
    
    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\View\View|string
     */
    public function render()
    {
        if ($this->responsive && $this->media->isImage()) {
            return app(MediaService::class)->getResponsiveImage($this->media, $this->sizes, $this->attributes);
        }
        
        return $this->media->render($this->attributes);
    }
}
```

To use the component in templates:

```php
<!-- Simple usage -->
<x-media-renderer :media="$media" />

<!-- Responsive image -->
<x-media-renderer :media="$media" :responsive="true" />

<!-- With custom attributes -->
<x-media-renderer :media="$media" :attributes="['class' => 'img-fluid', 'loading' => 'lazy']" />

<!-- With custom sizes -->
<x-media-renderer 
    :media="$media" 
    :responsive="true" 
    :sizes="['sm' => 400, 'md' => 800, 'lg' => 1200]" 
    :attributes="['sizes' => '(max-width: 768px) 100vw, 50vw']" 
/>
```

## Media Gallery Component

A gallery component for displaying multiple media items:

```php
namespace App\View\Components;

use Illuminate\Support\Collection;
use Illuminate\View\Component;

class MediaGallery extends Component
{
    public $media;
    public $columns;
    public $lightbox;
    
    /**
     * Create a new component instance.
     *
     * @param Collection $media
     * @param int $columns
     * @param bool $lightbox
     * @return void
     */
    public function __construct(Collection $media, $columns = 3, $lightbox = true)
    {
        $this->media = $media;
        $this->columns = $columns;
        $this->lightbox = $lightbox;
    }
    
    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\View\View
     */
    public function render()
    {
        return view('theme::components.media-gallery');
    }
}
```

```php
<!-- resources/themes/miata/components/media-gallery.blade.php -->
<div class="media-gallery">
    <div class="row">
        @foreach($media as $item)
            <div class="col-md-{{ 12 / $columns }}">
                <div class="gallery-item">
                    @if($item->isImage())
                        @if($lightbox)
                            <a href="{{ $item->getUrl() }}" data-fancybox="gallery" data-caption="{{ $item->caption }}">
                                <img src="{{ $item->getThumbnailUrl(400, 300) }}" alt="{{ $item->alt_text ?? $item->name }}" class="img-fluid">
                            </a>
                        @else
                            <img src="{{ $item->getThumbnailUrl(400, 300) }}" alt="{{ $item->alt_text ?? $item->name }}" class="img-fluid">
                        @endif
                    @elseif($item->isVideo())
                        <div class="video-thumbnail">
                            <img src="{{ $item->getThumbnailUrl(400, 300) }}" alt="{{ $item->alt_text ?? $item->name }}" class="img-fluid">
                            <a href="{{ $item->getUrl() }}" class="play-button" data-fancybox>
                                <i class="fas fa-play"></i>
                            </a>
                        </div>
                    @else
                        <a href="{{ $item->getUrl() }}" class="file-item">
                            <img src="{{ $item->getPlaceholderUrl() }}" alt="{{ $item->alt_text ?? $item->name }}" class="img-fluid">
                            <span class="file-name">{{ $item->name }}</span>
                        </a>
                    @endif
                    
                    @if($item->caption)
                        <div class="gallery-caption">
                            {{ $item->caption }}
                        </div>
                    @endif
                </div>
            </div>
        @endforeach
    </div>
</div>

@if($lightbox)
    @push('styles')
        <link rel="stylesheet" href="{{ theme_asset('css/fancybox.min.css') }}">
    @endpush
    
    @push('scripts')
        <script src="{{ theme_asset('js/fancybox.min.js') }}"></script>
        <script>
            $(document).ready(function() {
                $('[data-fancybox]').fancybox({
                    buttons: [
                        'zoom',
                        'slideShow',
                        'fullScreen',
                        'download',
                        'thumbs',
                        'close'
                    ]
                });
            });
        </script>
    @endpush
@endif
```

To use the gallery component:

```php
<!-- Simple gallery -->
<x-media-gallery :media="$mediaItems" />

<!-- Gallery with 4 columns -->
<x-media-gallery :media="$mediaItems" :columns="4" />

<!-- Gallery without lightbox -->
<x-media-gallery :media="$mediaItems" :lightbox="false" />
```

## Background Image Component

A component for rendering background images:

```php
namespace App\View\Components;

use App\Models\Media;
use Illuminate\View\Component;

class BackgroundImage extends Component
{
    public $media;
    public $tag;
    public $attributes;
    
    /**
     * Create a new component instance.
     *
     * @param Media $media
     * @param string $tag
     * @param array $attributes
     * @return void
     */
    public function __construct(Media $media, $tag = 'div', $attributes = [])
    {
        $this->media = $media;
        $this->tag = $tag;
        $this->attributes = $attributes;
    }
    
    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\View\View|string
     */
    public function render()
    {
        return view('theme::components.background-image');
    }
}
```

```php
<!-- resources/themes/miata/components/background-image.blade.php -->
<{{ $tag }} 
    style="background-image: url('{{ $media->getUrl() }}');"
    @foreach($attributes as $key => $value)
        {{ $key }}="{{ $value }}"
    @endforeach
>
    {{ $slot }}
</{{ $tag }}>
```

To use the background image component:

```php
<!-- Simple background div -->
<x-background-image :media="$media">
    <div class="content">
        <h2>Title</h2>
        <p>Content</p>
    </div>
</x-background-image>

<!-- Section with background image -->
<x-background-image :media="$media" tag="section" :attributes="['class' => 'hero-section', 'id' => 'hero']">
    <div class="container">
        <h1>Welcome to our site</h1>
        <p>This is a hero section with a background image</p>
    </div>
</x-background-image>
```

## Lazy Loading

Lazy loading improves page performance by only loading images when they are visible:

```php
<!-- resources/themes/miata/js/lazy-loading.js -->
document.addEventListener('DOMContentLoaded', function() {
    // Check if IntersectionObserver is supported
    if ('IntersectionObserver' in window) {
        const lazyImages = document.querySelectorAll('img[loading="lazy"]');
        
        const imageObserver = new IntersectionObserver(function(entries, observer) {
            entries.forEach(function(entry) {
                if (entry.isIntersecting) {
                    const lazyImage = entry.target;
                    
                    // Set src from data-src
                    if (lazyImage.dataset.src) {
                        lazyImage.src = lazyImage.dataset.src;
                    }
                    
                    // Set srcset from data-srcset
                    if (lazyImage.dataset.srcset) {
                        lazyImage.srcset = lazyImage.dataset.srcset;
                    }
                    
                    lazyImage.classList.remove('lazy');
                    imageObserver.unobserve(lazyImage);
                }
            });
        });
        
        lazyImages.forEach(function(lazyImage) {
            imageObserver.observe(lazyImage);
        });
    } else {
        // Fallback for browsers that don't support IntersectionObserver
        const lazyImages = document.querySelectorAll('img.lazy');
        
        // Load all images immediately
        lazyImages.forEach(function(lazyImage) {
            if (lazyImage.dataset.src) {
                lazyImage.src = lazyImage.dataset.src;
            }
            
            if (lazyImage.dataset.srcset) {
                lazyImage.srcset = lazyImage.dataset.srcset;
            }
            
            lazyImage.classList.remove('lazy');
        });
    }
});
```

## Media Helper Functions

Helper functions simplify media usage in templates:

```php
namespace App\Helpers;

use App\Models\Media;

class MediaHelper
{
    /**
     * Get media by ID
     *
     * @param int $id
     * @return Media|null
     */
    public static function getMedia($id)
    {
        return Media::find($id);
    }
    
    /**
     * Get media URL by ID
     *
     * @param int $id
     * @return string|null
     */
    public static function getMediaUrl($id)
    {
        $media = self::getMedia($id);
        
        return $media ? $media->getUrl() : null;
    }
    
    /**
     * Get media thumbnail URL by ID
     *
     * @param int $id
     * @param int $width
     * @param int $height
     * @return string|null
     */
    public static function getMediaThumbnailUrl($id, $width = 200, $height = 200)
    {
        $media = self::getMedia($id);
        
        return $media ? $media->getThumbnailUrl($width, $height) : null;
    }
    
    /**
     * Render media by ID
     *
     * @param int $id
     * @param array $attributes
     * @return string
     */
    public static function renderMedia($id, $attributes = [])
    {
        $media = self::getMedia($id);
        
        return $media ? $media->render($attributes) : '';
    }
}
```

Register the helper in the `AppServiceProvider`:

```php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\Blade;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        // Register media helper as a Blade directive
        Blade::directive('media', function ($expression) {
            return "<?php echo \\App\\Helpers\\MediaHelper::renderMedia($expression); ?>";
        });
        
        Blade::directive('mediaUrl', function ($expression) {
            return "<?php echo \\App\\Helpers\\MediaHelper::getMediaUrl($expression); ?>";
        });
        
        Blade::directive('mediaThumbnail', function ($expression) {
            return "<?php echo \\App\\Helpers\\MediaHelper::getMediaThumbnailUrl($expression); ?>";
        });
    }
}
```

To use the helper directives in templates:

```php
<!-- Render media -->
@media(1, ['class' => 'img-fluid'])

<!-- Get media URL -->
<a href="@mediaUrl(1)">Download</a>

<!-- Get media thumbnail -->
<img src="@mediaThumbnail(1, 300, 200)" alt="Thumbnail">
```

## Conclusion

The media handling system provides a comprehensive approach to managing and rendering media files in the CMS. By implementing a robust media model, service, and components, the system supports various media types, responsive images, lazy loading, and galleries. The implementation is designed to work seamlessly with the Miata template while providing a flexible backend architecture for media management.
