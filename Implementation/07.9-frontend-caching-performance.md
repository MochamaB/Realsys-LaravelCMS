# Frontend - Caching and Performance Optimization

This document outlines the caching and performance optimization strategies for the CMS, explaining how to improve frontend rendering speed and overall site performance.

## Performance Optimization Overview

The performance optimization system consists of several components:

1. **Page Caching**: Caching entire pages for faster delivery
2. **Fragment Caching**: Caching specific parts of pages
3. **Asset Optimization**: Minifying and combining CSS and JavaScript files
4. **Image Optimization**: Optimizing images for faster loading
5. **Database Query Optimization**: Reducing database queries
6. **Content Delivery Network (CDN)**: Using a CDN for static assets

## Page Caching

Full-page caching can significantly improve performance for pages that don't change frequently:

```php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;

class PageCacheMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle(Request $request, Closure $next)
    {
        // Skip caching for authenticated users or non-GET requests
        if ($request->user() || $request->method() !== 'GET') {
            return $next($request);
        }
        
        // Generate cache key based on URL and locale
        $cacheKey = 'page_cache_' . md5($request->url() . '_' . app()->getLocale());
        
        // Check if page is cached
        if (Cache::has($cacheKey)) {
            return response(Cache::get($cacheKey));
        }
        
        // Process the request
        $response = $next($request);
        
        // Cache the response if it's successful
        if ($response->status() === 200) {
            Cache::put($cacheKey, $response->getContent(), now()->addMinutes(60));
        }
        
        return $response;
    }
}
```

Register the middleware in the `Kernel.php` file:

```php
protected $routeMiddleware = [
    // ... other middleware
    'page.cache' => \App\Http\Middleware\PageCacheMiddleware::class,
];
```

Apply the middleware to routes:

```php
// routes/web.php

// Public pages with caching
Route::group(['middleware' => ['web', 'page.cache']], function () {
    Route::get('/', [App\Http\Controllers\Frontend\PageController::class, 'home'])->name('home');
    Route::get('/{slug}', [App\Http\Controllers\Frontend\PageController::class, 'show'])->name('page.show');
});
```

## Fragment Caching

For more dynamic pages, fragment caching can be used to cache specific parts:

```php
<!-- resources/themes/miata/partials/latest-posts.blade.php -->
@php
    $cacheKey = 'latest_posts_' . app()->getLocale() . '_' . $limit;
    $posts = Cache::remember($cacheKey, now()->addMinutes(30), function () use ($limit) {
        return \App\Models\Page::where('is_active', true)
            ->where('template_id', function ($query) {
                $query->select('id')
                    ->from('templates')
                    ->where('slug', 'post');
            })
            ->orderBy('created_at', 'desc')
            ->take($limit)
            ->get();
    });
@endphp

<div class="latest-posts">
    <h3>@t('messages.latest_news')</h3>
    <div class="row">
        @foreach($posts as $post)
            <div class="col-lg-4 col-md-6">
                <div class="post-card">
                    @if($post->featured_image)
                        <div class="post-image">
                            <img src="{{ asset('storage/' . $post->featured_image) }}" alt="{{ $post->getTranslated('title') }}">
                        </div>
                    @endif
                    <div class="post-content">
                        <h4><a href="{{ route('page.show', $post->slug) }}">{{ $post->getTranslated('title') }}</a></h4>
                        <p class="post-date">{{ $post->created_at->format('F d, Y') }}</p>
                        <p class="post-excerpt">{{ Str::limit(strip_tags($post->getTranslated('description')), 100) }}</p>
                        <a href="{{ route('page.show', $post->slug) }}" class="read-more">@t('messages.read_more')</a>
                    </div>
                </div>
            </div>
        @endforeach
    </div>
</div>
```

## Widget Caching

Widgets can be cached to improve performance:

```php
namespace App\Services;

use App\Models\Widget;
use Illuminate\Support\Facades\Cache;

class WidgetRenderingService
{
    /**
     * Render a widget with caching
     *
     * @param Widget $widget
     * @param int $cacheDuration Minutes to cache the widget
     * @return string
     */
    public function renderCached(Widget $widget, $cacheDuration = 60)
    {
        if (!$widget->is_active) {
            return '';
        }
        
        // Generate cache key
        $cacheKey = "widget_{$widget->id}_" . app()->getLocale();
        
        // Check if widget is cached
        if (Cache::has($cacheKey)) {
            return Cache::get($cacheKey);
        }
        
        // Render the widget
        $rendered = $widget->render();
        
        // Cache the rendered widget
        Cache::put($cacheKey, $rendered, now()->addMinutes($cacheDuration));
        
        return $rendered;
    }
}
```

## Menu Caching

Menus can be cached to reduce database queries:

```php
namespace App\Services;

use App\Models\Menu;
use Illuminate\Support\Facades\Cache;

class MenuService
{
    /**
     * Get a menu by its location with caching
     *
     * @param string $location
     * @param int $cacheDuration Minutes to cache the menu
     * @return Menu|null
     */
    public function getMenuByLocation($location, $cacheDuration = 60)
    {
        $cacheKey = "menu_{$location}_" . app()->getLocale();
        
        return Cache::remember($cacheKey, now()->addMinutes($cacheDuration), function () use ($location) {
            return Menu::getByLocation($location);
        });
    }
}
```

## Asset Optimization

Laravel Mix is used to compile, minify, and version assets:

```javascript
// webpack.mix.js
const mix = require('laravel-mix');

// Main theme assets
mix.js('resources/themes/miata/assets/js/main.js', 'public/themes/miata/js')
   .sass('resources/themes/miata/assets/sass/style.scss', 'public/themes/miata/css')
   .sass('resources/themes/miata/assets/sass/style-rtl.scss', 'public/themes/miata/css')
   .copy('resources/themes/miata/assets/images', 'public/themes/miata/images')
   .copy('resources/themes/miata/assets/fonts', 'public/themes/miata/fonts')
   .version();

// Admin theme assets
mix.js('resources/themes/velzon/assets/js/admin.js', 'public/themes/velzon/js')
   .sass('resources/themes/velzon/assets/sass/admin.scss', 'public/themes/velzon/css')
   .copy('resources/themes/velzon/assets/images', 'public/themes/velzon/images')
   .copy('resources/themes/velzon/assets/fonts', 'public/themes/velzon/fonts')
   .version();
```

Use versioned assets in templates:

```php
<!-- resources/themes/miata/layouts/default.blade.php -->
<!DOCTYPE html>
<html lang="{{ app()->getLocale() }}" dir="{{ config('app.available_locales')[app()->getLocale()]['direction'] }}">
<head>
    <!-- ... other head content ... -->
    
    <!-- CSS Files -->
    <link rel="stylesheet" href="{{ mix('themes/miata/css/style.css') }}">
    
    @if(config('app.available_locales')[app()->getLocale()]['direction'] === 'rtl')
        <link rel="stylesheet" href="{{ mix('themes/miata/css/style-rtl.css') }}">
    @endif
</head>
<body>
    <!-- ... body content ... -->
    
    <!-- JS Files -->
    <script src="{{ mix('themes/miata/js/main.js') }}"></script>
</body>
</html>
```

## Image Optimization

A service for optimizing images:

```php
namespace App\Services;

use Intervention\Image\Facades\Image;
use Illuminate\Support\Facades\Storage;

class ImageOptimizationService
{
    /**
     * Optimize an image
     *
     * @param string $path
     * @param int $quality
     * @return bool
     */
    public function optimize($path, $quality = 80)
    {
        // Check if the file exists
        if (!Storage::disk('public')->exists($path)) {
            return false;
        }
        
        // Get the full path
        $fullPath = Storage::disk('public')->path($path);
        
        // Get the image
        $image = Image::make($fullPath);
        
        // Optimize the image
        $image->save($fullPath, $quality);
        
        return true;
    }
    
    /**
     * Generate a responsive image set
     *
     * @param string $path
     * @param array $sizes
     * @param int $quality
     * @return array
     */
    public function generateResponsiveImages($path, $sizes = [], $quality = 80)
    {
        // Check if the file exists
        if (!Storage::disk('public')->exists($path)) {
            return [];
        }
        
        // Get the full path
        $fullPath = Storage::disk('public')->path($path);
        
        // Get the image
        $image = Image::make($fullPath);
        
        // Default sizes
        $defaultSizes = [
            'xs' => 576,
            'sm' => 768,
            'md' => 992,
            'lg' => 1200,
            'xl' => 1400,
        ];
        
        $sizes = array_merge($defaultSizes, $sizes);
        
        // Generate responsive images
        $responsiveImages = [];
        
        foreach ($sizes as $size => $width) {
            // Calculate height based on aspect ratio
            $height = round($width * ($image->height() / $image->width()));
            
            // Generate filename
            $filename = pathinfo($path, PATHINFO_FILENAME) . "_{$width}x{$height}." . pathinfo($path, PATHINFO_EXTENSION);
            $directory = pathinfo($path, PATHINFO_DIRNAME);
            $responsivePath = "{$directory}/{$filename}";
            
            // Resize and save the image
            $resizedImage = $image->resize($width, $height, function ($constraint) {
                $constraint->aspectRatio();
                $constraint->upsize();
            });
            
            $resizedImage->save(Storage::disk('public')->path($responsivePath), $quality);
            
            // Add to responsive images array
            $responsiveImages[$size] = [
                'path' => $responsivePath,
                'url' => Storage::disk('public')->url($responsivePath),
                'width' => $width,
                'height' => $height,
            ];
        }
        
        return $responsiveImages;
    }
}
```

## Lazy Loading Images

A Blade component for lazy loading images:

```php
namespace App\View\Components;

use Illuminate\View\Component;

class LazyImage extends Component
{
    public $src;
    public $alt;
    public $width;
    public $height;
    public $class;
    
    /**
     * Create a new component instance.
     *
     * @param string $src
     * @param string $alt
     * @param int|null $width
     * @param int|null $height
     * @param string|null $class
     * @return void
     */
    public function __construct($src, $alt = '', $width = null, $height = null, $class = null)
    {
        $this->src = $src;
        $this->alt = $alt;
        $this->width = $width;
        $this->height = $height;
        $this->class = $class;
    }
    
    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\View\View
     */
    public function render()
    {
        return view('theme::components.lazy-image');
    }
}
```

```php
<!-- resources/themes/miata/components/lazy-image.blade.php -->
<img 
    src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 {{ $width ?? 800 }} {{ $height ?? 600 }}'%3E%3C/svg%3E"
    data-src="{{ $src }}"
    alt="{{ $alt }}"
    @if($width) width="{{ $width }}" @endif
    @if($height) height="{{ $height }}" @endif
    class="{{ $class }} lazy"
    loading="lazy"
>
```

JavaScript for lazy loading:

```javascript
// resources/themes/miata/assets/js/lazy-loading.js
document.addEventListener('DOMContentLoaded', function() {
    // Check if IntersectionObserver is supported
    if ('IntersectionObserver' in window) {
        const lazyImages = document.querySelectorAll('img.lazy');
        
        const imageObserver = new IntersectionObserver(function(entries, observer) {
            entries.forEach(function(entry) {
                if (entry.isIntersecting) {
                    const lazyImage = entry.target;
                    
                    // Set src from data-src
                    if (lazyImage.dataset.src) {
                        lazyImage.src = lazyImage.dataset.src;
                    }
                    
                    // Set srcset from data-srcset
                    if (lazyImage.dataset.srcset) {
                        lazyImage.srcset = lazyImage.dataset.srcset;
                    }
                    
                    lazyImage.classList.remove('lazy');
                    imageObserver.unobserve(lazyImage);
                }
            });
        });
        
        lazyImages.forEach(function(lazyImage) {
            imageObserver.observe(lazyImage);
        });
    } else {
        // Fallback for browsers that don't support IntersectionObserver
        const lazyImages = document.querySelectorAll('img.lazy');
        
        // Load all images immediately
        lazyImages.forEach(function(lazyImage) {
            if (lazyImage.dataset.src) {
                lazyImage.src = lazyImage.dataset.src;
            }
            
            if (lazyImage.dataset.srcset) {
                lazyImage.srcset = lazyImage.dataset.srcset;
            }
            
            lazyImage.classList.remove('lazy');
        });
    }
});
```

## Database Query Optimization

Eager loading relationships to reduce database queries:

```php
namespace App\Http\Controllers\Frontend;

use App\Http\Controllers\Controller;
use App\Models\Page;
use App\Services\MenuService;
use Illuminate\Http\Request;

class PageController extends Controller
{
    protected $menuService;
    
    /**
     * Create a new controller instance.
     *
     * @param MenuService $menuService
     * @return void
     */
    public function __construct(MenuService $menuService)
    {
        $this->menuService = $menuService;
    }
    
    /**
     * Display the home page.
     *
     * @return \Illuminate\Http\Response
     */
    public function home()
    {
        // Get the home page
        $page = Page::where('is_home', true)
                    ->where('is_active', true)
                    ->with(['template', 'sections.widgets.widgetType.fields'])
                    ->firstOrFail();
        
        // Get menus
        $mainMenu = $this->menuService->getMenuByLocation('main');
        $footerMenu = $this->menuService->getMenuByLocation('footer');
        
        return view('theme::pages.home', compact('page', 'mainMenu', 'footerMenu'));
    }
    
    /**
     * Display a page.
     *
     * @param string $slug
     * @return \Illuminate\Http\Response
     */
    public function show($slug)
    {
        // Get the page
        $page = Page::where('slug', $slug)
                    ->where('is_active', true)
                    ->with(['template', 'sections.widgets.widgetType.fields'])
                    ->firstOrFail();
        
        // Get menus
        $mainMenu = $this->menuService->getMenuByLocation('main');
        $footerMenu = $this->menuService->getMenuByLocation('footer');
        
        return view('theme::pages.default', compact('page', 'mainMenu', 'footerMenu'));
    }
}
```

## Content Delivery Network (CDN)

Configure a CDN for static assets:

```php
// config/filesystems.php

'disks' => [
    // ... other disks
    
    'cdn' => [
        'driver' => 's3',
        'key' => env('AWS_ACCESS_KEY_ID'),
        'secret' => env('AWS_SECRET_ACCESS_KEY'),
        'region' => env('AWS_DEFAULT_REGION'),
        'bucket' => env('AWS_BUCKET'),
        'url' => env('AWS_URL'),
        'endpoint' => env('AWS_ENDPOINT'),
        'use_path_style_endpoint' => env('AWS_USE_PATH_STYLE_ENDPOINT', false),
    ],
],
```

Create a helper for CDN URLs:

```php
namespace App\Helpers;

use Illuminate\Support\Facades\Storage;

class CdnHelper
{
    /**
     * Get a CDN URL for an asset
     *
     * @param string $path
     * @return string
     */
    public static function asset($path)
    {
        if (config('app.use_cdn') && Storage::disk('cdn')->exists($path)) {
            return Storage::disk('cdn')->url($path);
        }
        
        return asset($path);
    }
}
```

Register the helper in the `AppServiceProvider`:

```php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\Blade;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }

    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        // Register CDN asset directive
        Blade::directive('cdn', function ($expression) {
            return "<?php echo \\App\\Helpers\\CdnHelper::asset($expression); ?>";
        });
    }
}
```

Use the CDN helper in templates:

```php
<img src="@cdn('themes/miata/images/logo.png')" alt="Logo">
```

## Cache Clearing

A command to clear all caches:

```php
namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\Cache;

class ClearAllCaches extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'cache:clear-all';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Clear all caches (application, view, config, route)';

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $this->info('Clearing all caches...');
        
        // Clear application cache
        $this->info('Clearing application cache...');
        Cache::flush();
        Artisan::call('cache:clear');
        $this->info('Application cache cleared!');
        
        // Clear view cache
        $this->info('Clearing view cache...');
        Artisan::call('view:clear');
        $this->info('View cache cleared!');
        
        // Clear config cache
        $this->info('Clearing config cache...');
        Artisan::call('config:clear');
        $this->info('Config cache cleared!');
        
        // Clear route cache
        $this->info('Clearing route cache...');
        Artisan::call('route:clear');
        $this->info('Route cache cleared!');
        
        $this->info('All caches cleared successfully!');
        
        return 0;
    }
}
```

## Cache Warming

A command to warm the cache:

```php
namespace App\Console\Commands;

use App\Models\Page;
use App\Services\MenuService;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\Cache;

class WarmCache extends Command
{
    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'cache:warm';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Warm the cache with frequently accessed data';

    /**
     * Execute the console command.
     *
     * @return int
     */
    public function handle()
    {
        $this->info('Warming cache...');
        
        // Cache menus
        $this->info('Caching menus...');
        $menuService = app(MenuService::class);
        
        foreach (['main', 'footer', 'sidebar'] as $location) {
            foreach (array_keys(config('app.available_locales')) as $locale) {
                $cacheKey = "menu_{$location}_{$locale}";
                $menu = $menuService->getMenuByLocation($location, 60, $locale);
                
                if ($menu) {
                    $this->info("Cached menu: {$location} ({$locale})");
                }
            }
        }
        
        // Cache pages
        $this->info('Caching pages...');
        $pages = Page::where('is_active', true)->get();
        
        foreach ($pages as $page) {
            foreach (array_keys(config('app.available_locales')) as $locale) {
                $cacheKey = "page_{$page->id}_{$locale}";
                
                Cache::put($cacheKey, $page, now()->addHours(24));
                
                $this->info("Cached page: {$page->title} ({$locale})");
            }
        }
        
        $this->info('Cache warming completed successfully!');
        
        return 0;
    }
}
```

## Performance Monitoring

A middleware for monitoring performance:

```php
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;

class PerformanceMonitoringMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle(Request $request, Closure $next)
    {
        // Start time
        $startTime = microtime(true);
        
        // Process the request
        $response = $next($request);
        
        // End time
        $endTime = microtime(true);
        
        // Calculate execution time
        $executionTime = $endTime - $startTime;
        
        // Log if execution time is above threshold (e.g., 1 second)
        if ($executionTime > 1) {
            Log::warning("Slow request: {$request->url()} ({$executionTime} seconds)");
        }
        
        // Add performance header
        $response->header('X-Execution-Time', $executionTime);
        
        return $response;
    }
}
```

Register the middleware in the `Kernel.php` file:

```php
protected $middlewareGroups = [
    'web' => [
        // ... other middleware
        \App\Http\Middleware\PerformanceMonitoringMiddleware::class,
    ],
];
```

## Conclusion

The caching and performance optimization system provides a comprehensive approach to improving the speed and efficiency of the CMS. By implementing page caching, fragment caching, asset optimization, image optimization, database query optimization, and CDN integration, the system ensures fast loading times and a smooth user experience. The implementation is designed to work seamlessly with the Miata template while providing a robust backend architecture for high-performance websites.
